grammar com.crubier.lil.Lil hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate lil "http://www.crubier.com/lil/Lil"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Model
Model:
	((interactors+=InteractorDeclaration) | (dataTypes+=DataTypeCompoundDeclaration))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Interactor
InteractorDeclaration:
	'interactor' name=ID ':'
	((entities+=EntityDeclaration) | (signals+=SignalDeclaration) | (behaviors+=BehaviorDeclaration))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Entities
AccessibleEntity:
	generic=('any' | 'self' | 'other' | 'parent' | 'child' | 'all' | 'actors') | specific=Entity;

Entity:
	instance=[EntityDeclaration];

Actor:
	instance=[ActorDeclaration];

Component:
	instance=[ComponentDeclaration];

EntityDeclaration:
	ActorDeclaration | ComponentDeclaration;

ActorDeclaration:
	'actor' name=ID ;

ActorAlias:
	source=Actor 'as' remote=Actor;

ComponentDeclaration:
	interactor=[InteractorDeclaration] name=ID ('with' aliases+=ActorAlias (',' aliases+=ActorAlias)*)? ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Signals

EventReception:
	(instance=[EventDeclaration] ('from' source=Component)?) | base = ('init');

FlowReception:
	instance=[FlowDeclaration] ('from' source=Component)?;
	
EventEmission:
	instance=[EventDeclaration] ('to' destination=Component)?;
	
FlowEmission:
	instance=[FlowDeclaration] ('to' destination=Component)?;
	
SignalDeclaration:
	EventDeclaration | FlowDeclaration;

EventDeclaration:
	type=DataType 'event' name=ID ('from' source=AccessibleEntity)? ('to' destinations+=AccessibleEntity)*;

FlowDeclaration:
	type=DataType 'flow' name=ID ('from' source=AccessibleEntity)? ('to' destinations+=AccessibleEntity)*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Behaviors
BehaviorDeclaration:
	cause=Cause ':' (effects+=Effect)+;

Cause:
	(OnCause | WhenCause) ;

OnCause:
	'on' event=EventReception ('if' guard=BooleanExpression)?;

WhenCause:
	'when' condition=BooleanExpression ('if' guard=BooleanExpression)?;

Effect:
	(AlwaysEffect | SetEffect | TriggerEffect)
;

AlwaysEffect:
	'always' target=FlowEmission '=' value=Expression
;

SetEffect:
	'set' target=FlowEmission '=' value=Expression
;

TriggerEffect:
	'trigger' target=EventEmission '=' value=Expression
;

Expression:
	NumberExpression
;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Compound data types
DataTypeCompoundDeclaration:
	'structure' name=ID ':'
	(fields+=DataTypeCompoundField)*;

DataTypeCompoundField:
	type=DataType name=ID;

DataType:
	({DataTypeCompound} type=[DataTypeCompoundDeclaration]) | 
	({DataTypeBase} type=('void' | 'symbol' | 'number' | 'text' | 'time' | 'reference'));


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Expressions
//We do not use xbase because we only need a small subset of it in order to be able to generate C code and in order to simplify the language
//So we are going to construct the expressions we need

//Boolean expressions
BooleanExpression:
	 BooleanDisjonction
;

BooleanDisjonction returns BooleanExpression:
	BooleanConjonction 
 	(({BooleanDisjonction.left=current} 'or') right=BooleanConjonction)*
;

BooleanConjonction returns BooleanExpression:
	BooleanUnary 
 	(({BooleanConjonction.left=current} 'and') right=BooleanUnary)*
;

BooleanUnary returns BooleanExpression:
	BooleanTerminalExpression |
	(( {BooleanNegation} '!')  operand=BooleanTerminalExpression )
;

BooleanTerminalExpression returns BooleanExpression:
	'(' BooleanExpression ')' |
	({BooleanLiteral} value=BooleanLiteral) |
	( {BooleanNumberComparison} 'qq' left=NumberExpression op=('=='|'!='|'<'|'>'|'<='|'>=') right=NumberExpression 'ee') 
;






//Numeric expressions
NumberExpression:
 NumberCompoundExpression;
 
 NumberCompoundExpression returns NumberExpression:
 	NumberAddition |
 	{NumberIfExpression} 'if' '(' if=BooleanExpression ')' then=NumberAddition (=>'else' else=NumberAddition)? |
 	{NumberSwitchExpressionNumber} 'switch' '(' switch=NumberExpression ')'  (=> cases+=NumberSwitchExpressionNumberCase)+ (=>'default' ':' default=NumberExpression )? |
 	{NumberSwitchExpressionText} 'switch' '(' switch=TextExpression ')'  (=> cases+=NumberSwitchExpressionTextCase)+ (=>'default' ':' default=NumberExpression )?
 ;
 
 NumberSwitchExpressionNumberCase :
 	'case' condition=NumberExpression ':' value=NumberExpression
 ;
 
  NumberSwitchExpressionTextCase :
 	'case' condition=TextExpression ':' value=NumberExpression
 ;
 
NumberAddition returns NumberExpression:
 NumberMultiplication
  (({NumberAddition.left=current} '+' | {NumberSubstraction.left=current} '-') right=NumberMultiplication)*;

NumberMultiplication returns NumberExpression:
 NumberPower 
 (({NumberMultiplication.left=current} '*' | {NumberDivision.left=current} '/'| {NumberModulo.left=current} '%') right=NumberPower)*;

NumberPower returns NumberExpression:
 NumberUnary 
 (({NumberPower.left=current} '^' ) right=NumberUnary)*;
 
NumberUnary returns NumberExpression:
	NumberTerminalExpression |
	(( {NumberOpposition} '-')  operand=NumberTerminalExpression );

NumberTerminalExpression returns NumberExpression:
  '(' NumberExpression ')' |
/*   	({NumberTerminalSignal} ref=[SignalDeclaration])|*/
  ({NumberLiteral} value=NumberLiteral) |
  {NumberFunctionExpression} function=ID ('(' arguments+=NumberExpression (',' arguments+=NumberExpression)* ')')? 
;


//Text expressions
TextExpression:
	TextJoin
;

TextJoin returns TextExpression:
	TextTerminalExpression
  (({TextJoin.left=current} '<>' ) right=TextTerminalExpression)*;

TextTerminalExpression returns TextExpression:
	{TextLiteral} value=TextLiteral
;








XExpression:
	XOrExpression
;

XOrExpression returns XExpression:
	XAndExpression (=>({XBinaryOperation.leftOperand=current} feature=OpOr) rightOperand=XAndExpression)*;

OpOr:
	'||';

XAndExpression returns XExpression:
	XEqualityExpression (=>({XBinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=XEqualityExpression)*;

OpAnd:
	'&&';

XEqualityExpression returns XExpression:
	XRelationalExpression (=>({XBinaryOperation.leftOperand=current} feature=OpEquality) rightOperand=XRelationalExpression)*;

OpEquality:
	'==' | '!=' ;

XRelationalExpression returns XExpression:
	XOtherOperatorExpression
	/*(=>({XInstanceOfExpression.expression=current} 'instanceof') type=JvmTypeReference |*/
	 (=>({XBinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=XOtherOperatorExpression);

OpCompare:
	'>=' | '<=' | '>' | '<' ;

XOtherOperatorExpression returns XExpression:
	XAdditiveExpression (=>({XBinaryOperation.leftOperand=current} feature=OpOther) rightOperand=XAdditiveExpression)*;

OpOther:
	  '<>'
	| '?:' ;

XAdditiveExpression returns XExpression:
	XMultiplicativeExpression (=>({XBinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=XMultiplicativeExpression)*;

OpAdd:
	'+' | '-';

XMultiplicativeExpression returns XExpression:
	XUnaryOperation (=>({XBinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=XUnaryOperation)*;

OpMulti:
	'*' | '/' | '%';

XUnaryOperation returns XExpression:
	{XUnaryOperation} feature=OpUnary operand=XUnaryOperation | XCastedExpression;

OpUnary:
	"!" | "-" | "+";
	
XCastedExpression returns XExpression:
	XMemberFeatureCall (=>({XCastedExpression.target=current} 'as') type=JvmTypeReference)*
;

XMemberFeatureCall returns XExpression:
	XPrimaryExpression
	(=>({XAssignment.assignable=current} ('.'|explicitStatic?="::") feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign) value=XAssignment
	|=>({XMemberFeatureCall.memberCallTarget=current} ("."|nullSafe?="?."|explicitStatic?="::")) 
		('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?  
		feature=[types::JvmIdentifiableElement|FeatureCallID] (
			=>explicitOperationCall?='(' 
				(
				    memberCallArguments+=XShortClosure
				  |	memberCallArguments+=XExpression (',' memberCallArguments+=XExpression)*
				)? 
			')')?
			memberCallArguments+=XClosure?
		)*;

XPrimaryExpression returns XExpression:
	XConstructorCall |
	XBlockExpression |
	XSwitchExpression |
	XFeatureCall |
	XLiteral |
	XIfExpression |
	XForLoopExpression |
	XWhileExpression |
	XDoWhileExpression |
	XThrowExpression |
	XReturnExpression |
	XTryCatchFinallyExpression |
	XParenthesizedExpression;

XLiteral returns XExpression:
	XCollectionLiteral |
	XClosure |
	XBooleanLiteral |
	XNumberLiteral |
	XNullLiteral |
	XStringLiteral |
	XTypeLiteral
;

XCollectionLiteral:
	XSetLiteral | XListLiteral
;

XSetLiteral:
	{XSetLiteral} '#' '{' (elements+=XExpression (',' elements+=XExpression )*)? '}'
;

XListLiteral:
	{XListLiteral} '#' '[' (elements+=XExpression (',' elements+=XExpression )*)? ']'
;

XClosure returns XExpression:
	=>({XClosure} 
	'[') 
		=>((declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?='|')? 
		expression=XExpressionInClosure 
	']';
	
XExpressionInClosure returns XExpression: 
	{XBlockExpression}
	(expressions+=XExpressionInsideBlock ';'?)*
;

XShortClosure returns XExpression:
	=>({XClosure} (declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?='|') expression=XExpression;

XParenthesizedExpression returns XExpression:
	'(' XExpression ')';

XIfExpression returns XExpression:
	{XIfExpression}
	'if' '(' if=XExpression ')'
	then=XExpression
	(=>'else' else=XExpression)?;

XSwitchExpression returns XExpression:
	{XSwitchExpression}
	'switch' (=>(localVarName=ValidID ':')? switch=XExpression
		| =>('(' localVarName=ValidID ':') switch=XExpression ')') '{'
	(cases+=XCasePart)+
	('default' ':' default=XExpression )?
	'}';

XCasePart:
	typeGuard=JvmTypeReference? ('case' case=XExpression)? 
		':' then=XExpression ;

XForLoopExpression returns XExpression:
	{XForLoopExpression}
	'for' '(' declaredParam=JvmFormalParameter ':' forExpression=XExpression ')'
		eachExpression=XExpression;

XWhileExpression returns XExpression:
	{XWhileExpression}
	'while' '(' predicate=XExpression ')'
		body=XExpression;
	
XDoWhileExpression returns XExpression:
	{XDoWhileExpression}
   'do'
       body=XExpression
   'while' '(' predicate=XExpression ')';

XBlockExpression returns XExpression: 
	{XBlockExpression}
	'{'
		(expressions+=XExpressionInsideBlock ';'?)*
	'}';

XExpressionInsideBlock returns XExpression:
	XVariableDeclaration | XExpression;

XVariableDeclaration returns XExpression:
	{XVariableDeclaration}
	(writeable?='var'|'val') (=>(type=JvmTypeReference name=ValidID) | name=ValidID) ('=' right=XExpression)?;

JvmFormalParameter returns types::JvmFormalParameter:
	(parameterType=JvmTypeReference)? name=ValidID;
	
FullJvmFormalParameter returns types::JvmFormalParameter:
	parameterType=JvmTypeReference name=ValidID;

XFeatureCall returns XExpression:
	{XFeatureCall}
	('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')? 
	feature=[types::JvmIdentifiableElement|IdOrSuper] 
	(=>explicitOperationCall?='(' 
		(
		    featureCallArguments+=XShortClosure
		  |	featureCallArguments+=XExpression (',' featureCallArguments+=XExpression)*
		)? 
	')')?
	featureCallArguments+=XClosure?;
	
FeatureCallID:
	ValidID | 'extends' | 'static' | 'import' | 'extension'
;

IdOrSuper :
	FeatureCallID | 'super'
;
	
XConstructorCall returns XExpression:
	{XConstructorCall}
	'new' constructor=[types::JvmConstructor|QualifiedName] 
	(=>'<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
	(=>'(' 
		(
		    arguments+=XShortClosure
		  |	arguments+=XExpression (',' arguments+=XExpression)*
		)? 
	')')?
	arguments+=XClosure?;

XBooleanLiteral returns XExpression :
	{XBooleanLiteral} ('false' | isTrue?='true');

XNullLiteral returns XExpression :
	{XNullLiteral} 'null';

XNumberLiteral returns XExpression :
	{XNumberLiteral} value=Number;

XStringLiteral returns XExpression:
	{XStringLiteral} value=STRING;

XTypeLiteral returns XExpression :
	{XTypeLiteral} 'typeof' '(' type=[types::JvmType|QualifiedName] (arrayDimensions+=ArrayBrackets)* ')'
;

XThrowExpression returns XExpression :
	{XThrowExpression} 'throw' expression=XExpression;
	
XReturnExpression returns XExpression :
	{XReturnExpression} 'return' (=>expression=XExpression)?;
	
XTryCatchFinallyExpression returns XExpression:
	{XTryCatchFinallyExpression}
	'try' 
		expression=XExpression
	(
		catchClauses+=XCatchClause+
		(=>'finally' finallyExpression=XExpression)?
	|	'finally' finallyExpression=XExpression
	);
	
XCatchClause :
	=>'catch' '(' declaredParam=FullJvmFormalParameter ')' expression=XExpression;


QualifiedName:
  ValidID (=>'.' ValidID)*;












/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Literals
SymbolLiteral returns ecore::EString : 
  ID
;

BooleanLiteral returns ecore::EBoolean : 
  'true' |'yes' | 'false'| 'no' 
;

NumberLiteral returns ecore::EDouble : 
  INT ('.' INT)?
;

TextLiteral returns ecore::EString :
	STRING
;

TimeLiteral returns ecore::ELong :
	(INT 'ms') | (INT ('.' INT)? 's') | (INT ('.' INT)? 'm') | (INT ('.' INT)? 'h') | (INT ('.' INT)? 'd') 
;

ReferenceLiteral returns ecore::EString :
	ID
;

IndexLiteral returns ecore::EInt : 
  INT
;

// Terminals
terminal ID  		: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		; 
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;

grammar com.crubier.lil.Lil hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate lil "http://www.crubier.com/lil/Lil"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Model
LilModel:
	((interactors+=Interactor) | (dataTypes+=DataTypeCompound))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Interactor
Interactor:
	'interactor' name=ID ':'
	((entities+=Entity) | (signals+=Signal) | (behaviors+=Behavior))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Entities
AccessibleEntity:
	generic=GenericEntity | specific=[Entity];
	
GenericEntity:
	'any' | 'self' | 'other' | 'parent' | 'child' | 'all' | 'actors'
;

Entity:
	Actor | Component;

Actor:
	name=ID ':' 'actor'  ;

ActorAlias:
	source=[Actor] 'as' alias=[Actor];

Component:
	name=ID ':' interactor=[Interactor] ( 'with' actors+=ActorAlias (',' actors+=ActorAlias)*)? ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Signals

SignalReception:
	(instance=[Signal] ('from' source=SignalAlias)? ) | 
	(init?='init');
	
SignalEmission:
	(instance=[Signal] ('to' destination=SignalAlias)?);

Signal:
	name=ID ':'  type=DataType mode=SignalMode ('from' source=SignalAlias)? ('to' destinations+=SignalAlias)*;

SignalAlias:
	source=AccessibleEntity ('as' alias=[Signal])?;
	
SignalMode:
	'event' | 'flow';

DataType:
	base=DataTypeBase | compound=[DataTypeCompound];

DataTypeBase:
	'void' | 'symbol' | 'number' | 'text' | 'time' | 'reference';

DataTypeCompound:
	'structure' name=ID ':'
	(fields+=DataTypeCompoundField)*;

DataTypeCompoundField:
	name=ID ':' type=DataType ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Behaviors
Behavior:
	cause=Cause ':' (effects+=Effect)+;

Cause:
	(OnCause | WhenCause) ;

OnCause:
	'on' event=SignalReception ('if' guard=XExpression)?;

WhenCause:
	'when' condition=XExpression ('if' guard=XExpression)?;

Effect:
	(AlwaysEffect | SetEffect | TriggerEffect)
;

AlwaysEffect:
	'always' target=SignalEmission '=' value=XExpression
;

SetEffect:
	'set' target=SignalEmission '=' value=XExpression
;

TriggerEffect:
	'trigger' target=SignalEmission '=' value=XExpression
;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Expressions
//We do not use xbase because we only need a subset of it in order to be able to generate C code and in order to simplify the language
//So we are going to construct the expressions language we need. It is similar to xbase on certain points, but still clearly different, semantically and syntaxically

XExpression:
	XOrExpression;

XOrExpression returns XExpression:
	XAndExpression (=>({XBinaryOperation.leftOperand=current} feature=OpOr) rightOperand=XAndExpression)*;

OpOr:
	'or';

XAndExpression returns XExpression:
	XEqualityExpression (=>({XBinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=XEqualityExpression)*;

OpAnd:
	'and';

XEqualityExpression returns XExpression:
	XRelationalExpression (=>({XBinaryOperation.leftOperand=current} feature=OpEquality) rightOperand=XRelationalExpression)*;

OpEquality:
	'==' | '!=' ;

XRelationalExpression returns XExpression:
	XOtherOperatorExpression (=>({XBinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=XOtherOperatorExpression)*;

OpCompare:
	'<=' | '>=' | '<' | '>' ;

XOtherOperatorExpression returns XExpression:
	XAdditiveExpression (=>({XBinaryOperation.leftOperand=current} feature=OpOther) rightOperand=XAdditiveExpression)*;

OpOther:
	  '<>' | '?:' ; //String join and groovy elvis operator for null checking

XAdditiveExpression returns XExpression:
	XMultiplicativeExpression (=>({XBinaryOperation.leftOperand=current} feature=OpAdd) rightOperand=XMultiplicativeExpression)*;

OpAdd:
	'+' | '-';

XMultiplicativeExpression returns XExpression:
	XUnaryOperation (=>({XBinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=XUnaryOperation)*;

OpMulti:
	'*' | '/' | '%';

XUnaryOperation returns XExpression:
	({XUnaryOperation} feature=OpUnary operand=XPrimaryExpression) | XPrimaryExpression;

OpUnary:
	"!" | "-" | "+";

XPrimaryExpression returns XExpression:
	XSwitchExpression | XIfExpression | XLiteral | XForEachExpression | XFunctionCallExpression | XParenthesizedExpression;

XLiteral returns XExpression:
	XCollectionLiteral | XBooleanLiteral | XNumberLiteral | XNullLiteral | XStringLiteral;

XCollectionLiteral:
	XSetLiteral | XListLiteral;

XSetLiteral:
	{XSetLiteral} '@{' (elements+=XExpression (',' elements+=XExpression )*)? '}';

XListLiteral:
	{XListLiteral} '@[' (elements+=XExpression (',' elements+=XExpression )*)? ']';

XParenthesizedExpression returns XExpression:
	'(' XExpression ')';

XIfExpression returns XExpression:
	{XIfExpression}
	'if' '(' if=XExpression =>')'
	(then=XExpression)
	(=>'else' else=XExpression);

XSwitchExpression returns XExpression:
	{XSwitchExpression}
	'switch' '(' switch=XExpression =>')' 
	 (cases+=XCasePart)+
	 (=>'default' ':' default=XExpression );

XCasePart:
	'case' case=XExpression ':' then=XExpression ;

XForEachExpression returns XExpression:
	{XForEachExpression}
	'for' 'each' '(' forExpression=XExpression ')'
		eachExpression=XExpression;

XFunctionCallExpression returns XExpression:
	{XFunctionCallExpression} function=BuiltInFunction '(' (arguments+=XExpression)? (',' arguments+=XExpression)* ')';


BuiltInFunction : //Same functions as c math.*
'Math.abs'|'Math.acos'|'Math.acosh' |'Math.asin'|'Math.asinh' |'Math.atan'|'Math.atanh' |'Math.atan2' |
'Math.ceil'|'Math.cos'|'Math.cosh' |'Math.exp'|'Math.floor'|'Math.fround' |'Math.hypot' |'Math.log'|
'Math.log10' |'Math.log2' |'Math.max'|'Math.min'|'Math.pow'|'Math.random'|'Math.round'|'Math.sign'|
'Math.sin'|'Math.sinh'|'Math.sqrt'|'Math.tan'|'Math.tanh'|'Math.trunc'|
'Set.orderby'|'Set.add'|'Set.find'|'Set.change'|'Set.remove';


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Literals
XBooleanLiteral returns XExpression :
	{XBooleanLiteral} ('false' | isTrue?='true');

XNullLiteral returns XExpression :
	{XNullLiteral} 'null';

XNumberLiteral returns XExpression :
	{XNumberLiteral} value= NUMBER;

XStringLiteral returns XExpression:
	{XStringLiteral} value=STRING;

//QualifiedName:
//  ValidID (=>'.' ValidID)*;









//Xtext Data types

NUMBER returns ecore::EDouble : INT ('.' INT)?;

// Terminals
terminal ID  		: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		; 
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;

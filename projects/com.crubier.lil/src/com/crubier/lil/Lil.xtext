grammar com.crubier.lil.Lil hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate lil "http://www.crubier.com/lil/Lil"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Model
LilModel:
	((interactors+=InteractorDeclaration) | (dataTypes+=DataTypeCompoundDeclaration))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Interactor
InteractorDeclaration:
	'interactor' name=ID ':'
	((entities+=EntityDeclaration) | (signals+=SignalDeclaration) | (behaviors+=BehaviorDeclaration))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Entities
AccessibleEntity:
	generic=('any' | 'self' | 'other' | 'parent' | 'child' | 'all' | 'actors') | specific=Entity;

Entity:
	instance=[EntityDeclaration];

Actor:
	instance=[ActorDeclaration];

Component:
	instance=[ComponentDeclaration];

EntityDeclaration:
	ActorDeclaration | ComponentDeclaration;

ActorDeclaration:
	'actor' name=ID ;

ActorAlias:
	source=Actor 'as' remote=Actor;

ComponentDeclaration:
	interactor=[InteractorDeclaration] name=ID ('with' aliases+=ActorAlias (',' aliases+=ActorAlias)*)? ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Signals

EventReception:
	(instance=[EventDeclaration] ('from' source=Component)?) | base = ('init');

FlowReception:
	instance=[FlowDeclaration] ('from' source=Component)?;
	
EventEmission:
	instance=[EventDeclaration] ('to' destination=Component)?;
	
FlowEmission:
	instance=[FlowDeclaration] ('to' destination=Component)?;
	
SignalDeclaration:
	EventDeclaration | FlowDeclaration;

EventDeclaration:
	type=DataType 'event' name=ID ('from' source=AccessibleEntity)? ('to' destinations+=AccessibleEntity)*;

FlowDeclaration:
	type=DataType 'flow' name=ID ('from' source=AccessibleEntity)? ('to' destinations+=AccessibleEntity)*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Behaviors
BehaviorDeclaration:
	cause=Cause ':' (effects+=Effect)+;

Cause:
	(OnCause | WhenCause) ;

OnCause:
	'on' event=EventReception ('if' guard=XExpression)?;

WhenCause:
	'when' condition=XExpression ('if' guard=XExpression)?;

Effect:
	(AlwaysEffect | SetEffect | TriggerEffect)
;

AlwaysEffect:
	'always' target=FlowEmission '=' value=XExpression
;

SetEffect:
	'set' target=FlowEmission '=' value=XExpression
;

TriggerEffect:
	'trigger' target=EventEmission '=' value=XExpression
;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Compound data types
DataTypeCompoundDeclaration:
	'structure' name=ID ':'
	(fields+=DataTypeCompoundField)*;

DataTypeCompoundField:
	type=DataType name=ID;

DataType:
	({DataTypeCompound} type=[DataTypeCompoundDeclaration]) | 
	({DataTypeBase} type=DataTypeBase);

DataTypeBase:
	'void' | 'symbol' | 'number' | 'text' | 'time' | 'reference'
;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Expressions
//We do not use xbase because we only need a subset of it in order to be able to generate C code and in order to simplify the language
//So we are going to construct the expressions language we need. It is similar to xbase on certain points, but still clearly different, semantically and syntaxically

XExpression:
	XOrExpression
;

XOrExpression returns XExpression:
	XAndExpression (=>({XBinaryOperation.leftOperand=current} feature=OpOr) rightOperand=XAndExpression)*;

OpOr:
	'or';

XAndExpression returns XExpression:
	XEqualityExpression (=>({XBinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=XEqualityExpression)*;

OpAnd:
	'and';

XEqualityExpression returns XExpression:
	XRelationalExpression (=>({XBinaryOperation.leftOperand=current} feature=OpEquality) rightOperand=XRelationalExpression)*;

OpEquality:
	'==' | '!=' ;

XRelationalExpression returns XExpression:
	XOtherOperatorExpression
	/*(=>({XInstanceOfExpression.expression=current} 'instanceof') type=JvmTypeReference |*/
	 (=>({XBinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=XOtherOperatorExpression);

OpCompare:
	'>=' | '<=' | '>' | '<' ;

XOtherOperatorExpression returns XExpression:
	XAdditiveExpression (=>({XBinaryOperation.leftOperand=current} feature=OpOther) rightOperand=XAdditiveExpression)*;

OpOther:
	  '<>'
	| '?:' ;

XAdditiveExpression returns XExpression:
	XMultiplicativeExpression (=>({XBinaryOperation.leftOperand=current} feature=OpAdd)
	rightOperand=XMultiplicativeExpression)*;

OpAdd:
	'+' | '-';

XMultiplicativeExpression returns XExpression:
	XUnaryOperation (=>({XBinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=XUnaryOperation)*;

OpMulti:
	'*' | '/' | '%';

XUnaryOperation returns XExpression:
	{XUnaryOperation} feature=OpUnary operand=XUnaryOperation | XPrimaryExpression;

OpUnary:
	"!" | "-" | "+";
	
/* TODO HERE Add access to signals	
XCastedExpression returns XExpression:
	XMemberFeatureCall (=>({XCastedExpression.target=current} 'as') type=JvmTypeReference)*
;

XMemberFeatureCall returns XExpression:
	XPrimaryExpression
	(=>({XAssignment.assignable=current} ('.'|explicitStatic?="::") feature=[types::JvmIdentifiableElement|FeatureCallID] OpSingleAssign) value=XAssignment
	|=>({XMemberFeatureCall.memberCallTarget=current} ("."|nullSafe?="?."|explicitStatic?="::")) 
		('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?  
		feature=[types::JvmIdentifiableElement|FeatureCallID] (
			=>explicitOperationCall?='(' 
				(
				    memberCallArguments+=XShortClosure
				  |	memberCallArguments+=XExpression (',' memberCallArguments+=XExpression)*
				)? 
			')')?
			memberCallArguments+=XClosure?
		)*;

* */

XPrimaryExpression returns XExpression:
	XSwitchExpression |
	XIfExpression |
	XForEachExpression |
	XFunctionCallExpression |
	XParenthesizedExpression |
	XLiteral;

XLiteral returns XExpression:
	XCollectionLiteral |
	XBooleanLiteral |
	XNumberLiteral |
	XNullLiteral |
	XStringLiteral
;

XCollectionLiteral:
	XSetLiteral | XListLiteral
;

XSetLiteral:
	{XSetLiteral} '@{' (elements+=XExpression (',' elements+=XExpression )*)? '}'
;

XListLiteral:
	{XListLiteral} '@[' (elements+=XExpression (',' elements+=XExpression )*)? ']'
;

//XClosure returns XExpression:
//	=>({XClosure} 
//	'[') 
//		=>((declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?='|')? 
//		expression=XExpressionInClosure 
//	']';
//	
//XExpressionInClosure returns XExpression: 
//	{XBlockExpression}
//	(expressions+=XExpressionInsideBlock ';'?)*
//;
//
//XShortClosure returns XExpression:
//	=>({XClosure} (declaredFormalParameters+=JvmFormalParameter (',' declaredFormalParameters+=JvmFormalParameter)*)? explicitSyntax?='|') expression=XExpression;

XParenthesizedExpression returns XExpression:
	'(' XExpression ')';

XIfExpression returns XExpression:
	{XIfExpression}
	'if' '(' if=XExpression ')'
	then=XExpression
	(=>'else' else=XExpression)?;

//TODO remove the need for braces
XSwitchExpression returns XExpression:
	{XSwitchExpression}
	'switch' =>'(' switch=XExpression ')' /*'{'*/
	 (=> cases+=XCasePart)+
	 (=>'default' ':' default=XExpression )?
	/*'}'*/;

XCasePart:
	'case' case=XExpression ':' then=XExpression ;

XForEachExpression returns XExpression:
	{XForEachExpression}
	'for' 'each' '(' forExpression=XExpression ')'
		eachExpression=XExpression;

XFunctionCallExpression returns XExpression:
	{XFunctionCallExpression} function=BuiltInFunction '(' (arguments+=XExpression)? (',' arguments+=XExpression)* ')'
;

//Same functions as c math.*
BuiltInFunction :
'Math.abs'|'Math.acos'|'Math.acosh' |'Math.asin'|'Math.asinh' |'Math.atan'|'Math.atanh' |'Math.atan2' |
'Math.ceil'|'Math.cos'|'Math.cosh' |'Math.exp'|'Math.floor'|'Math.fround' |'Math.hypot' |'Math.log'|
'Math.log10' |'Math.log2' |'Math.max'|'Math.min'|'Math.pow'|'Math.random'|'Math.round'|'Math.sign'|
'Math.sin'|'Math.sinh'|'Math.sqrt'|'Math.tan'|'Math.tanh'|'Math.trunc'|
'Set.orderby'|'Set.add'|'Set.find'|'Set.change'|'Set.remove'  
;

//XWhileExpression returns XExpression:
//	{XWhileExpression}
//	'while' '(' predicate=XExpression ')'
//		body=XExpression;
//	
//XDoWhileExpression returns XExpression:
//	{XDoWhileExpression}
//   'do'
//       body=XExpression
//   'while' '(' predicate=XExpression ')';
//
//XBlockExpression returns XExpression: 
//	{XBlockExpression}
//	'{'
//		(expressions+=XExpressionInsideBlock ';'?)*
//	'}';
//
//XExpressionInsideBlock returns XExpression:
//	XVariableDeclaration | XExpression;
//
//XVariableDeclaration returns XExpression:
//	{XVariableDeclaration}
//	(writeable?='var'|'val') (=>(type=JvmTypeReference name=ValidID) | name=ValidID) ('=' right=XExpression)?;
//
//JvmFormalParameter returns types::JvmFormalParameter:
//	(parameterType=JvmTypeReference)? name=ValidID;
//	
//FullJvmFormalParameter returns types::JvmFormalParameter:
//	parameterType=JvmTypeReference name=ValidID;
//
//XFeatureCall returns XExpression:
//	{XFeatureCall}
//	('<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')? 
//	feature=[types::JvmIdentifiableElement|IdOrSuper] 
//	(=>explicitOperationCall?='(' 
//		(
//		    featureCallArguments+=XShortClosure
//		  |	featureCallArguments+=XExpression (',' featureCallArguments+=XExpression)*
//		)? 
//	')')?
//	featureCallArguments+=XClosure?;
//	
//FeatureCallID:
//	ValidID | 'extends' | 'static' | 'import' | 'extension'
//;
//
//IdOrSuper :
//	FeatureCallID | 'super'
//;
//	
//XConstructorCall returns XExpression:
//	{XConstructorCall}
//	'new' constructor=[types::JvmConstructor|QualifiedName] 
//	(=>'<' typeArguments+=JvmArgumentTypeReference (',' typeArguments+=JvmArgumentTypeReference)* '>')?
//	(=>'(' 
//		(
//		    arguments+=XShortClosure
//		  |	arguments+=XExpression (',' arguments+=XExpression)*
//		)? 
//	')')?
//	arguments+=XClosure?;




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Literals
XBooleanLiteral returns XExpression :
	{XBooleanLiteral} ('false' | isTrue?='true');

XNullLiteral returns XExpression :
	{XNullLiteral} 'null';

XNumberLiteral returns XExpression :
	{XNumberLiteral} value= NUMBER;

XStringLiteral returns XExpression:
	{XStringLiteral} value=STRING;

//QualifiedName:
//  ValidID (=>'.' ValidID)*;









//Xtext Data types

NUMBER returns ecore::EDouble : INT ('.' INT)?;

// Terminals
terminal ID  		: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		; 
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;

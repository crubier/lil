grammar com.crubier.lil.Lil hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate lil "http://www.crubier.com/lil/Lil"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Model
LilModel:
	((interactors+=Interactor) | (dataTypes+=DataTypeDefinition))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Interactor
Interactor:
	'interactor' name=ID ':'
	((entities+=Entity) | (signals+=Signal) | (behaviors+=Behavior))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Entities
AccessibleEntity:
	generic=GenericEntity | specific=[Entity];
	
GenericEntity:
	'any' | 'self' | 'other' | 'parent' | 'child' | 'all' | 'actors'
;

Entity:
	Actor | Component;

Actor:
	name=ID ':' 'actor'  ;

ActorAlias:
	source=[Actor] 'as' alias=[Actor];

Component:
	name=ID ':' interactor=[Interactor] ( 'with' actors+=ActorAlias (',' actors+=ActorAlias)*)? ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Signals

SignalReception:
	(instance=[Signal] ('from' source=SignalAlias)? ) | 
	(init?='init');
	
SignalEmission:
	(instance=[Signal] ('to' destination=SignalAlias)?);

Signal:
	name=ID ':' type=DataType mode=SignalMode ('from' source=SignalAlias)? ('to' destinations+=SignalAlias)*;

DefinitionSet:
	{EnumDefinitionSet} '{' elements+=EnumElement (',' elements+=EnumElement)* '}' |
	{NumberDefinitionSet} '{' elements+=NumberLiteral (',' elements+=NumberLiteral)*'}' |
	{NumberDefinitionInterval} '[' inf=NumberLiteral ',' sup=NumberLiteral ']'
;

SignalAlias:
	source=AccessibleEntity ('as' alias=[Signal])?;
	
SignalMode:
	'event' | 'flow';

DataType:
	{DataTypeBase} type=TypeBase ('in' definitionSet=DefinitionSet)? | 
	{DataTypeCollection} structure=('set'|'list'|'map') ('in' definitionSet=DefinitionSet)? | 
	compound=[DataTypeStructure] ;

TypeBase:
	'void' | 'symbol' | 'number' | 'text' | 'time' | 'reference';

DataTypeDefinition:
	DataTypeStructure
;

DataTypeStructure:
	'structure' name=ID ':'
	(fields+=DataTypeStructureField)*;

DataTypeStructureField:
	name=ID ':' type=DataType ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Behaviors
Behavior:
	cause=Cause ':' (effects+=Effect)+;

Cause:
	(OnCause | WhenCause) ;

OnCause:
	'on' event=SignalReception ('if' guard=Expression)?;

WhenCause:
	'when' condition=Expression ('if' guard=Expression)?;

Effect:
	(AlwaysEffect | SetEffect | TriggerEffect)
;

AlwaysEffect:
	'always' target=SignalEmission '=' value=Expression
;

SetEffect:
	'set' target=SignalEmission '=' value=Expression
;

TriggerEffect:
	'trigger' target=SignalEmission '=' value=Expression
;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Expressions
//We do not use xbase because we only need a subset of it in order to be able to generate C code and in order to simplify the language
//So we are going to construct the expressions language we need. It is similar to xbase on certain points, but still clearly different, semantically and syntaxically

Expression:
	OrExpression;

OrExpression returns Expression:
	AndExpression (=>({XBinaryOperation.leftOperand=current} feature=OpOr) rightOperand=AndExpression)*;

OpOr:
	'or';

AndExpression returns Expression:
	EqualityExpression (=>({XBinaryOperation.leftOperand=current} feature=OpAnd) rightOperand=EqualityExpression)*;

OpAnd:
	'and';

EqualityExpression returns Expression:
	RelationalExpression (=>({XBinaryOperation.leftOperand=current} feature=OpEquality) rightOperand=RelationalExpression)*;

OpEquality:
	'==' | '!=' ;

RelationalExpression returns Expression:
	OtherOperatorExpression (=>({XBinaryOperation.leftOperand=current} feature=OpCompare) rightOperand=OtherOperatorExpression)*;

OpCompare:
	'<=' | '>=' | '<' | '>' ;

OtherOperatorExpression returns Expression:
	AdditiveExpression (=>({XBinaryOperation.leftOperand=current} feature=OpOther) rightOperand=AdditiveExpression)*;

OpOther:
	  '<>' | '?:' ; //String join and groovy elvis operator for null checking

AdditiveExpression returns Expression:
	MultiplicativeExpression (=>({XBinaryOperation.leftOperand=current} feature=OpAdd) rightOperand=MultiplicativeExpression)*;

OpAdd:
	'+' | '-';

MultiplicativeExpression returns Expression:
	UnaryOperation (=>({XBinaryOperation.leftOperand=current} feature=OpMulti) rightOperand=UnaryOperation)*;

OpMulti:
	'*' | '/' | '%';

UnaryOperation returns Expression:
	({UnaryOperation} feature=OpUnary operand=PrimaryExpression) | PrimaryExpression;

OpUnary:
	"!" | "-" | "+";

PrimaryExpression returns Expression:
	SwitchExpression | IfExpression | Literal | ForEachExpression | FunctionCallExpression | ParenthesizedExpression;

Literal returns Expression:
	CollectionLiteral | BooleanLiteral | NumberLiteral | NullLiteral | StringLiteral | ({EnumLiteral} '#'element=[EnumElement] )| {SignalLiteral} signal=[Signal];

CollectionLiteral:
	SetLiteral | ListLiteral;

SetLiteral:
	{SetLiteral} '{' (elements+=Expression (',' elements+=Expression )*)? '}';

ListLiteral:
	{ListLiteral} '[' (elements+=Expression (',' elements+=Expression )*)? ']';

ParenthesizedExpression returns Expression:
	'(' Expression ')';

IfExpression returns Expression:
	{IfExpression}
	'if' '(' if=Expression =>')'
	(then=Expression)
	(=>'else' else=Expression);

SwitchExpression returns Expression:
	{SwitchExpression}
	'switch' '(' switch=Expression =>')' 
	 (=> cases+=CasePart)+
	 (=>'default' ':' default=Expression )?;

CasePart:
	'case' case=Expression ':' then=Expression ;

ForEachExpression returns Expression:
	{ForEachExpression}
	'for' 'each' '(' forExpression=Expression ')'
		eachExpression=Expression;

FunctionCallExpression returns Expression:
	{FunctionCallExpression} function=BuiltInFunction '(' (arguments+=Expression)? (',' arguments+=Expression)* ')';


BuiltInFunction : //Same functions as c math.*
'Math.abs'|'Math.acos'|'Math.acosh' |'Math.asin'|'Math.asinh' |'Math.atan'|'Math.atanh' |'Math.atan2' |
'Math.ceil'|'Math.clip'|'Math.cos'|'Math.cosh' |'Math.exp'|'Math.floor'|'Math.fround' |'Math.hypot' |'Math.log'|
'Math.log10' |'Math.log2' |'Math.max'|'Math.min'|'Math.pow'|'Math.random'|'Math.round'|'Math.sign'|
'Math.sin'|'Math.sinh'|'Math.sqrt'|'Math.tan'|'Math.tanh'|'Math.trunc'|
'Set.orderby'|'Set.add'|'Set.find'|'Set.change'|'Set.remove';


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Literals
BooleanLiteral returns Expression :
	{BooleanLiteral} ('false' | isTrue?='true');

NullLiteral returns Expression :
	{NullLiteral} 'null';

NumberLiteral returns Expression :
	{NumberLiteral} value= NUMBER;

StringLiteral returns Expression:
	{StringLiteral} value=STRING;

EnumElement :
	{EnumLiteral} '#'name=ID;

//QualifiedName:
//  ValidID (=>'.' ValidID)*;









//Xtext Data types

NUMBER returns ecore::EDouble : INT ('.' INT)?;

// Terminals
terminal ID  		: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING	: 
			'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
			"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
		; 
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;

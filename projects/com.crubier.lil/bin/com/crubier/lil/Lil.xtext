grammar com.crubier.lil.Lil with  org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate lil "http://www.crubier.com/lil/Lil"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Model
Model:
	((interactors+=InteractorDeclaration) | (dataTypes+=DataTypeCompoundDeclaration))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Interactor
InteractorDeclaration:
	'interactor' name=ID ':'
	((entities+=EntityDeclaration) | (signals+=SignalDeclaration) | (behaviors+=BehaviorDeclaration))*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Entities
AccessibleEntity:
	generic=('any' | 'self' | 'other' | 'parent' | 'child' | 'all' | 'actors') | specific=Entity;

Entity:
	instance=[EntityDeclaration];

Actor:
	instance=[ActorDeclaration];

Component:
	instance=[ComponentDeclaration];

EntityDeclaration:
	ActorDeclaration | ComponentDeclaration;

ActorDeclaration:
	'actor' name=ID ;

ActorAlias:
	source=Actor 'as' remote=Actor;

ComponentDeclaration:
	interactor=[InteractorDeclaration] name=ID ('with' aliases+=ActorAlias (',' aliases+=ActorAlias)*)? ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Signals

EventReception:
	(instance=[EventDeclaration] ('from' source=Component)?) | base = ('init');

FlowReception:
	instance=[FlowDeclaration] ('from' source=Component)?;
	
EventEmission:
	instance=[EventDeclaration] ('to' destination=Component)?;
	
FlowEmission:
	instance=[FlowDeclaration] ('to' destination=Component)?;
	
SignalDeclaration:
	EventDeclaration | FlowDeclaration;

EventDeclaration:
	type=DataType 'event' name=ID ('from' source=AccessibleEntity)? ('to' destinations+=AccessibleEntity)*;

FlowDeclaration:
	type=DataType 'flow' name=ID ('from' source=AccessibleEntity)? ('to' destinations+=AccessibleEntity)*;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Behaviors
BehaviorDeclaration:
	cause=Cause ':' (effects+=Effect)+;

Cause:
	(OnCause | WhenCause) ;

OnCause:
	'on' event=EventReception ('if' guard=XExpression)?;

WhenCause:
	'when' condition=XExpression ('if' guard=XExpression)?;

Effect:
	(AlwaysEffect | SetEffect | TriggerEffect)
;

AlwaysEffect:
	'always' target=FlowEmission '=' value=XExpression
;

SetEffect:
	'set' target=FlowEmission '=' value=XExpression
;

TriggerEffect:
	'trigger' target=EventEmission '=' value=XExpression
;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Compound data types
DataTypeCompoundDeclaration:
	'structure' name=ID ':'
	(fields+=DataTypeCompoundField)*;

DataTypeCompoundField:
	type=DataType name=ID;

DataType:
	({DataTypeCompound} type=[DataTypeCompoundDeclaration]) | 
	({DataTypeBase} type=('void' | 'symbol' | 'number' | 'text' | 'time' | 'reference'));


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Expressions
//We do not use xbase because we only need a small subset of it in order to be able to generate C code and in order to simplify the language
//So we are going to construct the expressions we need
